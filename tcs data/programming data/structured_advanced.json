[
  {
    "id": 1,
    "problem_statement": "Problem Statement: Alice and her friends are playing a game of verbal Kho-Kho. Alice is acting as a mediator, and the rest of the N friends are seated on N chairs, one each.\nAlice starts by providing a paper with a single-digit number to the friend present at number 1. Let\u2019s denote friends by F, where F will be of size N. F[1]\u2026F[N] represents friends seated respectively. After receiving the paper with a digit, F[1] will enact and try to tell F[2] without speaking. Similarly, F[2] will communicate to the next person i.e., F[3]. This continues until the last person F[N] understands the digit. Finally, the last person will write the digit on a separate paper and give it to Alice to compare both papers. If the digits are similar then, Alice will give a T-shirt to each friend. However, if the digits do not match, Alice will ask each friend\u2019s digits, and she will offer the T-shirts to only those who understood the digits correctly. Given N number of friends and digit array D, denoting the digit understood by each friend F. finds out how many of Alice\u2019s friends have not enacted well OR did not understand the enactment by the previous friend correctly. Example 1:\n3 -> N, number of friends\n4 4 4 \u2013 array D. denoting digit understanding by N friends\nOutput:\n0\nExplanation:\nAll of them understood the digits correctly. Example 2:\n5\n1 2 3 2 2\nOutput:\n4\nExplanation:\n1st, 2nd, 3rd, and 4th friends could not enact OR understand the enactment.",
    "example": [
      "Example 1:\n3 -> N, number of friends\n4 4 4 \u2013 array D. denoting digit understanding by N friends\nOutput:\n0\nExplanation:\nAll of them understood the digits correctly.",
      "Example 2:\n5\n1 2 3 2 2\nOutput:\n4\nExplanation:\n1st, 2nd, 3rd, and 4th friends could not enact OR understand the enactment."
    ],
    "input": null,
    "output": [
      "0\nExplanation:\nAll of them understood the digits correctly.",
      "4\nExplanation:\n1st, 2nd, 3rd, and 4th friends could not enact OR understand the enactment."
    ],
    "solution": "Solution:- n = int(input()) arr = list(map(int, input().split())) print(n-arr.count(arr[0]))"
  },
  {
    "id": 2,
    "problem_statement": "Problem Statement: Bob is going to bet today on horse riding. There are N horses listed in a sequence of 1 to N. The probability of winning each horse is different so the prices for making a bet on the horses are not the same. There is no limit on the number of horses on which he can bet, but he thinks that if he bets on a continuous sequence of horses then he has a better chance to win. Bob will get K units of money if any horse on which he bets will win. But as the award is only K units so he wants to put money less than K. Bob wants to bet on as many horses as he can. As you are his best friend, he reached out to you for help, can you please find the length of the maximum continuous sequence of horses on which Bob can make a bet, and remember he will invest money less than K units. If there is more than one possible combination, Bob will bet randomly on any one of them. Given the number of horses(N), reward money(K), and price of betting on N horses in order. Hint:\u00a0For each starting index of a horse, its end index in sequences will be equal to or greater than the end index of the previous starting index. Example 1: Input:\n90 100 -> N = 10, K=100\n30 40 50 20 20 10 90 10 10 10 -> Price to make bet on each horse in order Output:\n3 Explanation:\nThere are 10 horses, and the reward money is 100. So, Bob will put money in less than 100. There are two possible o sequences of length three whose total money for betting is less than 100, i.e. [50 20 20] (sum is 90) and [10 10 10] (sum is 30). Bob will choose randomly one sequence from these two. As none of the other sequences with a length greater than 3 will have a price less than 100 so the answer will be 3. Example 2: Input:\n10 100 -> N = 10, K=100\n10 90 80 20 90 60 40 60 70 75 -> Price to make bet on each horse in order Output:\n1 Explanation:\nThere are no two consecutive horses for which the sum of price is less than 100. So, Bob will choose randomly any one horse. And the max length of the sequence will be 1. Constraints: 2<=N<=105 1<= K<=109 1<=A1, A3\u2026 AN<=109 The Input format for testing: The candidate has to write the code to accept 2 inputs. First Input:\u00a0It will contain two integers N (number of horses) and K (reward money) Second Input:\u00a0It will contain N integers, each separated",
    "example": [
      "Example 1: Input:\n90 100 -> N = 10, K=100\n30 40 50 20 20 10 90 10 10 10 -> Price to make bet on each horse in order Output:\n3 Explanation:\nThere are 10 horses, and the reward money is 100. So, Bob will put money in less than 100. There are two possible o sequences of length three whose total money for betting is less than 100, i.e. [50 20 20] (sum is 90) and [10 10 10] (sum is 30). Bob will choose randomly one sequence from these two. As none of the other sequences with a length greater than 3 will have a price less than 100 so the answer will be 3.",
      "Example 2: Input:\n10 100 -> N = 10, K=100\n10 90 80 20 90 60 40 60 70 75 -> Price to make bet on each horse in order Output:\n1 Explanation:\nThere are no two consecutive horses for which the sum of price is less than 100. So, Bob will choose randomly any one horse. And the max length of the sequence will be 1. Constraints: 2<=N<=105 1<= K<=109 1<=A1, A3\u2026 AN<=109 The Input format for testing: The candidate has to write the code to accept 2 inputs. First Input:\u00a0It will contain two integers N (number of horses) and K (reward money) Second Input:\u00a0It will contain N integers, each separated"
    ],
    "input": [
      "90 100 -> N = 10, K=100\n30 40 50 20 20 10 90 10 10 10 -> Price to make bet on each horse in order",
      "10 100 -> N = 10, K=100\n10 90 80 20 90 60 40 60 70 75 -> Price to make bet on each horse in order",
      "It will contain two integers N (number of horses) and K (reward money) Second Input:\u00a0It will contain N integers, each separated"
    ],
    "output": [
      "3 Explanation:\nThere are 10 horses, and the reward money is 100. So, Bob will put money in less than 100. There are two possible o sequences of length three whose total money for betting is less than 100, i.e. [50 20 20] (sum is 90) and [10 10 10] (sum is 30). Bob will choose randomly one sequence from these two. As none of the other sequences with a length greater than 3 will have a price less than 100 so the answer will be 3.",
      "1 Explanation:\nThere are no two consecutive horses for which the sum of price is less than 100. So, Bob will choose randomly any one horse. And the max length of the sequence will be 1. Constraints: 2<=N<=105 1<= K<=109 1<=A1, A3\u2026 AN<=109 The"
    ],
    "solution": "Solution:- def fun(n, k, arr): ans = 0 if min(arr) < k: ans = 1 for i in range(n - 1): for j in range(i + 1, n): if sum(arr[i:j]) < k: ans = max(ans, j - i) else: break return ans n, k = map(int, input().split()) arr = list(map(int, input().split())) print(fun(n, k, arr))"
  },
  {
    "id": 3,
    "problem_statement": "Problem Statement: This vacation you went to visit the golden house. There are N rooms in this golden house and its owner needs someone to take care of the management of this house. As you have been unemployed for a long time, you are interested in this job. The owner of this house wanted an intelligent manager for this role, so he created one puzzle within that golden house. The person who will be able to solve that puzzle will be the manager of the golden house. The owner of the house kept some number of golden coins in each room. You have to choose two rooms, one from where you will enter and the other one from where you will exit. From any room either you can exit, or you can move to the next room. While visiting any room you will collect all the gold coins, and if you enter any room then you can\u2019t skip collecting gold coins from that room, you have to take those coins. The owner wants to have exactly K coins, when you exit the room, he guarantees that there will be at least one possible solution for this puzzle. Given several rooms (N), and several gold coins in N rooms. You have to find room numbers from where you will start and from where you will exit. If there is more than one solution possible, then you have to provide a solution with a smaller starting room number.\nYou can assume that room numbers will start from 1 and end at N. Hint:\u00a0Find a continuous subsequence whose sum will be exactly equal to K. Example 1: Input:\n10 15 -> N =10, K = 15\n5 3 7 14 18 1 18 4 8 3 -> Number of gold coins in each room. Output:\n1 3 Explanation:\u00a0There are ten rooms in the house. You want to have the Total sum of gold coins in a continuous sequence of rooms to be 15 There are two solutions to this i.e. [1, 3] and [8, 10] then the solution with a smaller starting room number will be printed hence [1, 3] is output.",
    "example": [
      "Example 1: Input:\n10 15 -> N =10, K = 15\n5 3 7 14 18 1 18 4 8 3 -> Number of gold coins in each room. Output:\n1 3 Explanation:\u00a0There are ten rooms in the house. You want to have the Total sum of gold coins in a continuous sequence of rooms to be 15 There are two solutions to this i.e. [1, 3] and [8, 10] then the solution with a smaller starting room number will be printed hence [1, 3] is output."
    ],
    "input": [
      "10 15 -> N =10, K = 15\n5 3 7 14 18 1 18 4 8 3 -> Number of gold coins in each room."
    ],
    "output": [
      "1 3 Explanation:\u00a0There are ten rooms in the house. You want to have the Total sum of gold coins in a continuous sequence of rooms to be 15 There are two solutions to this i.e. [1, 3] and [8, 10] then the solution with a smaller starting room number will be printed hence [1, 3] is output."
    ],
    "solution": "Solution:- def fun(n, k, arr): for i in range(n - 1): for j in range(i, n): if sum(arr[i:j]) == k: return [i + 1, j] n, k = map(int, input().split()) arr = list(map(int, input().split())) s = fun(n, k, arr) print(s[0], s[1])"
  },
  {
    "id": 4,
    "problem_statement": "Problem Statement: Tina was given a piece of silk cloth. There are already a few points or coordinates mentioned on it.\u00a0She is creating something which needs an exact square shape cloth.\u00a0Help Tina to find out how many minimum points she can add, to cut the perfect square from the given cloth.\nThere are already a few points marked on one cloth, Tina has to include the most number of points from the given points and should try to include the minimum number of points or coordinates from her side. Find the minimum number of coordinates to achieve the perfect square. Also, try to get as bigger cloth as possible.\nLet us try to understand it with an example\nLet\u2019s say there are 3 points given means N=3\nThese points are:\nLet us try to understand it with an example Let\u2019s say there are 3 points given, which means N=3 These points are\n0 0\n2 2\n3 3\nWe can have 2 additional coordinates: (2,0) & (0,2)\nOR (3,0) & (0,3) Tina doesn\u2019t want to lose a good deal here, so better if she would go with (3,0) & (0,3).\u00a0Hence 2 additional coordinates were required to cut a perfect square from that piece of cloth.\nHence the answer is 2 Example 1: Input:\n5 -> Input integer, N\n0 0 -> Input integer, x[i], y[i]\n100 100 -> Input integer, x[i], y[i]\n200 200 -> Input integer, x[i], y[i]\n100 0 -> Input integer, x[i], y[i]\n0 100 ->Input integer, x[i], y[i] Output:\n0 -> Output Explanation:\nIn the above scenario, we can already make a square from the given coordinates\nP1: (0, 0)\nP2: (100, 0)\nP3: (0, 100)\nP4: (100, 100)\nHence no need for any additional coordinates here.\nSo the answer is No. Example 2: Input:\n3 -> Input integer. N\n0 0 -> Input integer, x[i], y[i]\n2 2 -> Input integer, x[i], y[i]\n3 3 -> Input integer, x[i], y[i] Output:\n2 -> Output Explanation:\nIn the above scenario, we can have 2 additional co-ordinates: (20)&(0,2)\nOR (3,0)&(0.3) Tina doesn\u2019t want to lose a good deal here so\u00a0better if she would go with (3,0), (0,3).\nHence 2 additional co-ordinates were required\u00a0to cut a perfect square from that piece of cloth.\nHence the answer is 2.",
    "example": [
      "Example 1: Input:\n5 -> Input integer, N\n0 0 -> Input integer, x[i], y[i]\n100 100 -> Input integer, x[i], y[i]\n200 200 -> Input integer, x[i], y[i]\n100 0 -> Input integer, x[i], y[i]\n0 100 ->Input integer, x[i], y[i] Output:\n0 -> Output Explanation:\nIn the above scenario, we can already make a square from the given coordinates\nP1: (0, 0)\nP2: (100, 0)\nP3: (0, 100)\nP4: (100, 100)\nHence no need for any additional coordinates here.\nSo the answer is No.",
      "Example 2: Input:\n3 -> Input integer. N\n0 0 -> Input integer, x[i], y[i]\n2 2 -> Input integer, x[i], y[i]\n3 3 -> Input integer, x[i], y[i] Output:\n2 -> Output Explanation:\nIn the above scenario, we can have 2 additional co-ordinates: (20)&(0,2)\nOR (3,0)&(0.3) Tina doesn\u2019t want to lose a good deal here so\u00a0better if she would go with (3,0), (0,3).\nHence 2 additional co-ordinates were required\u00a0to cut a perfect square from that piece of cloth.\nHence the answer is 2."
    ],
    "input": [
      "5 -> Input integer, N\n0 0 -> Input integer, x[i], y[i]\n100 100 -> Input integer, x[i], y[i]\n200 200 -> Input integer, x[i], y[i]\n100 0 -> Input integer, x[i], y[i]\n0 100 ->Input integer, x[i], y[i]",
      "3 -> Input integer. N\n0 0 -> Input integer, x[i], y[i]\n2 2 -> Input integer, x[i], y[i]\n3 3 -> Input integer, x[i], y[i]"
    ],
    "output": [
      "0 -> Output Explanation:\nIn the above scenario, we can already make a square from the given coordinates\nP1: (0, 0)\nP2: (100, 0)\nP3: (0, 100)\nP4: (100, 100)\nHence no need for any additional coordinates here.\nSo the answer is No.",
      "2 -> Output Explanation:\nIn the above scenario, we can have 2 additional co-ordinates: (20)&(0,2)\nOR (3,0)&(0.3) Tina doesn\u2019t want to lose a good deal here so\u00a0better if she would go with (3,0), (0,3).\nHence 2 additional co-ordinates were required\u00a0to cut a perfect square from that piece of cloth.\nHence the answer is 2."
    ],
    "solution": "Solution:- from itertools import combinations def fun(n, arr): if n < 3: return 4 - n elif n == 3: if distSq(arr[0], arr[1]) == distSq(arr[1], arr[2]) == distSq(arr[0], arr[2]): return 1 else: return 2 else: arrr = com(4, arr) for i in arrr: if isSquare(i[0], i[1], i[2], i[3]): return 0 arrr = com(3, arr) for i in arrr: print(i) if distSq(i[0], i[1]) == distSq(i[1], i[2]) == distSq(i[0], i[2]): return 1 return 2 def isSquare(p1, p2, p3, p4): d2 = distSq(p1, p2) d3 = distSq(p1, p3) d4 = distSq(p1, p4) if d2 == 0 or d3 == 0 or d4 == 0: return False if d2 == d3 and 2 * d2 == d4 and 2 * distSq(p2, p4) == distSq(p2, p3): return True if d3 == d4 and 2 * d3 == d2 and 2 * distSq(p3, p2) == distSq(p3, p4): return True if d2 == d4 and 2 * d2 == d3 and 2 * distSq(p2, p3) == distSq(p2, p4): return True return False def com(n, arr): a = [] comb = combinations(arr, n) for i in comb: a.append(list(i)) return a def distSq(p, q): return (p[0] - q[0]) * (p[0] - q[0]) + (p[1] - q[1]) * (p[1] - q[1]) N = int(input()) ar = [] for i in range(N): ar.append(list(map(int, input().split()))) print(fun(N, ar))"
  },
  {
    "id": 5,
    "problem_statement": "Problem Statement: Jack is a sports teacher at St. Patrick\u2019s School. He makes games not only to make the student fit but So smart.\u00a0So, he lined up all the N number classes. of students in his class.\u00a0At each position, he has fixed a board with the Integer number printed on it. Each number is unique and in exactly the range of N. Let us say there are 10 students, then the boards will be printed with numbers from 1 to 10 in a random order given by the sequence A[ ].\u00a0As a rule, all students wear a jersey with their numbers printed on it. So if there are students, each will have a unique jersey number just like a football team.\u00a0Now, in the beginning, all the students will stand as per the increasing order of their jersey numbers, from left to right.\u00a0The only difference will be their respective board number which is placed at their respective location. The board location is fixed and cannot be changed. We can consider the arrangement as below. Suppose there are students, and the board is placed in the order of [2 3 1 5 4].\nBoard \u2014 2, 3, 1, 5, 4\nStudent\u2019s Jersey \u2014 1, 2, 3, 4, 5\nNow the game begins. After every beat of the drum, each student will have to move to that location (index), where his board is pointing to. In the above case student with jersey #1 is standing with board #2, so now he will have to move to location #2. Similarly, all the other students will do. So after the first beat of the drum, the alignment will be:\nBoard \u2014 2, 3, 1, 5, 4.\nThis keeps going on and on until all the students are back to the way they were at the beginning. So, after 6 beats of the drum, all the students will be aligned the same way as before. Given N and the order of the board of the respective positions, find the number of beats required to bring back the students to their original position.\nSo, for the above case, the answer is 6 Example 1: Input:\n3 -> Input integer, N\n{1, 2, 3} ->Input integer. B[], board alignment. Output:\n1 -> Output Explanation:\nAll the students will be standing in board positions;\nBoard \u2014 1, 2, 3\nStudent\u2019s Jersey \u20131, 2, 3 After the first beat of the drum:\nJersey #1 will move to index 1.\nJersey #2 will move to index 2.\nJersey #3 will move to index 3.\nHence, they will be back in their position in just 1 beat.\nSo, the answer is 1. Example 2: Input:\n5 -> Input integer, N\n{2, 3, 1, 5, 4} -> Input integer, B[ ], board alignment. Output:\n6 -> Output Explanation:\nAll the students will be standing as below, with the board positions:\nBoard \u2014 2, 3, 1, 5, 4\nStudent\u2019s Jersey \u2014 1, 2, 3, 4, 5 After Beat-1of the drum:\nJersey #1 has moved to index 2.\nJersey #2 has moved to index 3.\nJersey #3 has moved to index 1.\nJersey #4 has moved to index 5.\nJersey #5 has moved to index 4. Board \u2013 2, 3, 1, 5, 4\nStudent\u2019s Jersey \u2014 3, 1, 2, 5, 4 After Beat-2 of the drum:\nJersey #3 has moved to index 2.\nJersey #1 has moved to index 3.\nJersey #2 has moved to index 1.\nJersey #5 has moved to index 5.\nJersey #4 has moved to index 4. Board \u2014 2, 3, 1, 5, 4\nStudent\u2019s Jersey \u2014 2, 3, 1, 4, 5 After Beat-3 of the drum:\nBoard \u2014 2, 3, 1, 5, 4\nStudent\u2019s Jersey \u2014 1, 2, 3, 5, 4\n\nAfter Beat-4 of the drum:\nBoard \u2014 2, 3, 1, 5, 4\nStudent\u2019s Jersey \u2014 3, 1, 2, 4, 5 After Beat-5 of the drum:\nBoard \u2014 2, 3, 1, 5, 4\nStudent\u2019s Jersey \u2014 2, 3, 1, 5, 4 After Beat-6 of the drum:\nBoard \u2014 2, 3, 1, 5, 4\nStudent\u2019s Jersey \u2014 1, 2, 3, 4, 5 Hence, they will be back in their positions after 6 beats.\nSo, the answer is 6.",
    "example": [
      "Example 1: Input:\n3 -> Input integer, N\n{1, 2, 3} ->Input integer. B[], board alignment. Output:\n1 -> Output Explanation:\nAll the students will be standing in board positions;\nBoard \u2014 1, 2, 3\nStudent\u2019s Jersey \u20131, 2, 3 After the first beat of the drum:\nJersey #1 will move to index 1.\nJersey #2 will move to index 2.\nJersey #3 will move to index 3.\nHence, they will be back in their position in just 1 beat.\nSo, the answer is 1.",
      "Example 2: Input:\n5 -> Input integer, N\n{2, 3, 1, 5, 4} -> Input integer, B[ ], board alignment. Output:\n6 -> Output Explanation:\nAll the students will be standing as below, with the board positions:\nBoard \u2014 2, 3, 1, 5, 4\nStudent\u2019s Jersey \u2014 1, 2, 3, 4, 5 After Beat-1of the drum:\nJersey #1 has moved to index 2.\nJersey #2 has moved to index 3.\nJersey #3 has moved to index 1.\nJersey #4 has moved to index 5.\nJersey #5 has moved to index 4. Board \u2013 2, 3, 1, 5, 4\nStudent\u2019s Jersey \u2014 3, 1, 2, 5, 4 After Beat-2 of the drum:\nJersey #3 has moved to index 2.\nJersey #1 has moved to index 3.\nJersey #2 has moved to index 1.\nJersey #5 has moved to index 5.\nJersey #4 has moved to index 4. Board \u2014 2, 3, 1, 5, 4\nStudent\u2019s Jersey \u2014 2, 3, 1, 4, 5 After Beat-3 of the drum:\nBoard \u2014 2, 3, 1, 5, 4\nStudent\u2019s Jersey \u2014 1, 2, 3, 5, 4\n\nAfter Beat-4 of the drum:\nBoard \u2014 2, 3, 1, 5, 4\nStudent\u2019s Jersey \u2014 3, 1, 2, 4, 5 After Beat-5 of the drum:\nBoard \u2014 2, 3, 1, 5, 4\nStudent\u2019s Jersey \u2014 2, 3, 1, 5, 4 After Beat-6 of the drum:\nBoard \u2014 2, 3, 1, 5, 4\nStudent\u2019s Jersey \u2014 1, 2, 3, 4, 5 Hence, they will be back in their positions after 6 beats.\nSo, the answer is 6."
    ],
    "input": [
      "3 -> Input integer, N\n{1, 2, 3} ->Input integer. B[], board alignment.",
      "5 -> Input integer, N\n{2, 3, 1, 5, 4} -> Input integer, B[ ], board alignment."
    ],
    "output": [
      "1 -> Output Explanation:\nAll the students will be standing in board positions;\nBoard \u2014 1, 2, 3\nStudent\u2019s Jersey \u20131, 2, 3 After the first beat of the drum:\nJersey #1 will move to index 1.\nJersey #2 will move to index 2.\nJersey #3 will move to index 3.\nHence, they will be back in their position in just 1 beat.\nSo, the answer is 1.",
      "6 -> Output Explanation:\nAll the students will be standing as below, with the board positions:\nBoard \u2014 2, 3, 1, 5, 4\nStudent\u2019s Jersey \u2014 1, 2, 3, 4, 5 After Beat-1of the drum:\nJersey #1 has moved to index 2.\nJersey #2 has moved to index 3.\nJersey #3 has moved to index 1.\nJersey #4 has moved to index 5.\nJersey #5 has moved to index 4. Board \u2013 2, 3, 1, 5, 4\nStudent\u2019s Jersey \u2014 3, 1, 2, 5, 4 After Beat-2 of the drum:\nJersey #3 has moved to index 2.\nJersey #1 has moved to index 3.\nJersey #2 has moved to index 1.\nJersey #5 has moved to index 5.\nJersey #4 has moved to index 4. Board \u2014 2, 3, 1, 5, 4\nStudent\u2019s Jersey \u2014 2, 3, 1, 4, 5 After Beat-3 of the drum:\nBoard \u2014 2, 3, 1, 5, 4\nStudent\u2019s Jersey \u2014 1, 2, 3, 5, 4\n\nAfter Beat-4 of the drum:\nBoard \u2014 2, 3, 1, 5, 4\nStudent\u2019s Jersey \u2014 3, 1, 2, 4, 5 After Beat-5 of the drum:\nBoard \u2014 2, 3, 1, 5, 4\nStudent\u2019s Jersey \u2014 2, 3, 1, 5, 4 After Beat-6 of the drum:\nBoard \u2014 2, 3, 1, 5, 4\nStudent\u2019s Jersey \u2014 1, 2, 3, 4, 5 Hence, they will be back in their positions after 6 beats.\nSo, the answer is 6."
    ],
    "solution": "Solution:- n = int(input()) B = [] arr = [] for i in range(n): B.append(int(input())) arr.append(i + 1) ans = 0 while 1: ans += 1 ar = [None] * n for i in range(n): ar[i] = arr[B[i] - 1] if ar == sorted(ar): break arr = ar print(ans)"
  },
  {
    "id": 6,
    "problem_statement": "Problem Statement: Ayush is working on a strange algorithm where he wants to convert a string from A to B, both the strings of equal length N\nBelow are the rules which can be performed to\u00a0 convert a string String A and B are of equal length Both of them are in lower case Choose a subset X from the string A, between the index 1 and N. Let \u2018s\u2019 be the letter that alphabetically comes before all other letters in the subset. Let \u2018s\u2019 be called the \u2018smallest element\u2019 in the subset. Replace all the elements of the subset with the letter \u2018s\u2019 Find the minimum number of moves which is required to perform the conversion. If it is not possible to convert the string from A to b then return -1\nLet us try to understand it with examples\u00a0Suppose there are 2 strings\u00a0\nA = abcab\nB = aabab\nOperation 1: 2\nNow we have chosen a subset S, let us say we have taken indexes 2,3,5 from A then the subset S becomes [bcb].\u00a0Next, we have to choose the smallest element, 6041 here, which is b here in b & c.\u00a0Next, we have to replace all the other elements in the subset with this element. So \u2018b\u2019 with replace everything in [bcb]. which becomes [bbb].\u00a0Now we will place all the respective elements back in their respective index. This will update the original string as [abbab].\nOperation 2:\nOriginal string [abbab].\u00a0Now we have chosen a subset S, let\u2019s say we have taken an index 1,2,4 from A then the subset becomes [aba].\u00a0Next, we have to choose the smallest element, which is here in a & b.\u00a0Next, we have to replace the smallest with all the other elements in the subset. So \u2018a\u2019 will replace everything in [aba].\u00a0Now we will place all the respective elements back in their respective index. This will update the original string as [aabab].\u00a0This is the same as String B.\u00a0Hence it is possible to convert string A to B, with 2\u00a0operations.\nSo, the answer is 2. Example 1:\nInput:\n2\u00a0 \u00a0-> Input integer, N\u00a0\nde -> input string, A\u00a0\ncd -> Input string, A\nOutput:\u00a0-1 -> Output\nExplanation:\nIn the above example, we can see that there is an alphabet in A which is completely different from B. hence it is not possible to convert A to B\nSo the answer is -1 Example 2:\nInput:\n4-> input integer, N\nabab-> input string, A\u00a0\nabaa-> input string A\nOutput:\n1 -> Output\nExplanation:\nOperation 1:\nNow we have chosen a subset S, let\u2019s say we have taken\u00a0\nindex 3, 4 from A\nThen Subset S becomes [ab]\nNext, we have to choose the smallest element, which is a\u00a0here in a & b\nNext, we have to replace the smallest with all the other\u00a0elements in a subset. So \u2018a\u2019 will replace everything in [abl, which becomes [aa]\nNow we will place all the respective elements back in their respective index. This will update the original string as [abaa]\nThis is the same as String B\nHence it is possible to convert string A to B. with 1 operation. So, the answer is 1.",
    "example": [
      "Example 1:\nInput:\n2\u00a0 \u00a0-> Input integer, N\u00a0\nde -> input string, A\u00a0\ncd -> Input string, A\nOutput:\u00a0-1 -> Output\nExplanation:\nIn the above example, we can see that there is an alphabet in A which is completely different from B. hence it is not possible to convert A to B\nSo the answer is -1",
      "Example 2:\nInput:\n4-> input integer, N\nabab-> input string, A\u00a0\nabaa-> input string A\nOutput:\n1 -> Output\nExplanation:\nOperation 1:\nNow we have chosen a subset S, let\u2019s say we have taken\u00a0\nindex 3, 4 from A\nThen Subset S becomes [ab]\nNext, we have to choose the smallest element, which is a\u00a0here in a & b\nNext, we have to replace the smallest with all the other\u00a0elements in a subset. So \u2018a\u2019 will replace everything in [abl, which becomes [aa]\nNow we will place all the respective elements back in their respective index. This will update the original string as [abaa]\nThis is the same as String B\nHence it is possible to convert string A to B. with 1 operation. So, the answer is 1."
    ],
    "input": [
      "2\u00a0 \u00a0-> Input integer, N\u00a0\nde -> input string, A\u00a0\ncd -> Input string, A",
      "4-> input integer, N\nabab-> input string, A\u00a0\nabaa-> input string A"
    ],
    "output": [
      "-1 -> Output\nExplanation:\nIn the above example, we can see that there is an alphabet in A which is completely different from B. hence it is not possible to convert A to B\nSo the answer is -1",
      "1 -> Output\nExplanation:\nOperation 1:\nNow we have chosen a subset S, let\u2019s say we have taken\u00a0\nindex 3, 4 from A\nThen Subset S becomes [ab]\nNext, we have to choose the smallest element, which is a\u00a0here in a & b\nNext, we have to replace the smallest with all the other\u00a0elements in a subset. So \u2018a\u2019 will replace everything in [abl, which becomes [aa]\nNow we will place all the respective elements back in their respective index. This will update the original string as [abaa]\nThis is the same as String B\nHence it is possible to convert string A to B. with 1 operation. So, the answer is 1."
    ],
    "solution": "Solution:- n = int(input()) a = input() b = input() if a == b: print(1) res, res2 = \"\", \"\" for x in range(n): if a[x] != b[x]: res += a[x] res2 += b[x] ans = 0 for i in a: if ans != 0: break if i not in b: print(-1) break else: for x in set(res2): if x not in a: print(-1) ans += 1 break else: print(len(set(res2))) ans += 1 break if ans == 1: break"
  },
  {
    "id": 7,
    "problem_statement": "Problem Statement: At the security checkpoint, airport security personnel have seized a number of travellers\u2019 belongings. Everything has been thrown into a big box (array). Each product carries a specific level of risk[0,1,2]. The risk severity of the items in this case is represented by an array[] of N integer values. Sorting the elements in the array according to the degrees of danger is the task at hand. Between 0 and 2 are the risk values. Example\u00a0: Input : 7\u00a0 -> Value of N [1,0,2,0,1,0,2]-> Element of arr[0] to arr[N-1], while input each element is separated by new line. Output : 0 0 0 1 1 2 2\u00a0 -> Element after sorting based on risk severity Example 2: input : 10\u00a0 -> Value of N [2,1,0,2,1,0,0,1,2,0] -> Element of arr[0] to arr[N-1], while input each element is separated by a new line. Output : 0 0 0 0 1 1 1 2 2 2\u00a0 ->Elements after sorting based on risk severity. Explanation: In the above example, the input is an array of size N consisting of only 0\u2019s, 1\u2019s and 2s. The output is a sorted array from 0 to 2 based on risk severity.",
    "example": [
      "Example\u00a0: Input : 7\u00a0 -> Value of N [1,0,2,0,1,0,2]-> Element of arr[0] to arr[N-1], while input each element is separated by new line. Output : 0 0 0 1 1 2 2\u00a0 -> Element after sorting based on risk severity",
      "Example 2: input : 10\u00a0 -> Value of N [2,1,0,2,1,0,0,1,2,0] -> Element of arr[0] to arr[N-1], while input each element is separated by a new line. Output : 0 0 0 0 1 1 1 2 2 2\u00a0 ->Elements after sorting based on risk severity. Explanation: In the above example, the input is an array of size N consisting of only 0\u2019s, 1\u2019s and 2s. The output is a sorted array from 0 to 2 based on risk severity."
    ],
    "input": [
      "7\u00a0 -> Value of N [1,0,2,0,1,0,2]-> Element of arr[0] to arr[N-1], while input each element is separated by new line."
    ],
    "output": [
      "0 0 0 1 1 2 2\u00a0 -> Element after sorting based on risk severity",
      "0 0 0 0 1 1 1 2 2 2\u00a0 ->Elements after sorting based on risk severity. Explanation: In the above example, the input is an array of size N consisting of only 0\u2019s, 1\u2019s and 2s. The output is a sorted array from 0 to 2 based on risk severity."
    ],
    "solution": "Solution:- def dutch_national_flag_sort(arr): l, m, h = 0, 0, len(arr) - 1 while m <= h: if arr[m] == 0: arr[l], arr[m] = arr[m], arr[l] l += 1 m += 1 elif arr[m] == 1: m += 1 else: arr[m], arr[h] = arr[h], arr[m] h -= 1 return arr # Input n = int(input()) a = list(map(int, input().split())) # Sorting sorted_array = dutch_national_flag_sort(a) # Output print(\" \".join(map(str, sorted_array)))"
  },
  {
    "id": 8,
    "problem_statement": "Problem Statement: For all of its products, a supermarket maintains a pricing structure. Each product has a value N printed on it. The price of the item is determined by multiplying the value N, which is read by the scanner, by the sum of all its digits. The goal here is to create software that, given the code of any item N, will compute the product (multiplication) of all the value digits (price). Example 1: Input : 5244 -> Value of N Output :\n160 -> Price Explanation: From the input above\u00a0\nProduct of the digits 5,2,4,4\n5*2*4*4= 160\nHence, output is 160.",
    "example": [
      "Example 1: Input : 5244 -> Value of N Output :\n160 -> Price Explanation: From the input above\u00a0\nProduct of the digits 5,2,4,4\n5*2*4*4= 160\nHence, output is 160."
    ],
    "input": [
      "5244 -> Value of N"
    ],
    "output": [
      "160 -> Price Explanation: From the input above\u00a0\nProduct of the digits 5,2,4,4\n5*2*4*4= 160\nHence, output is 160."
    ],
    "solution": "Solution: n=input() p=1 for i in n: p*=int(i) print(p)"
  },
  {
    "id": 9,
    "problem_statement": "Problem Statement: There are two banks \u2013 Bank A and Bank B. Their interest rates vary. You have received offers from both banks in terms of the annual rate of interest, tenure, and variations of the rate of interest over the entire tenure. You have to choose the offer which costs you the least interest and reject the other. Do the computation and make a wise choice. The loan repayment happens at a monthly frequency and Equated Monthly Installment (EMI) is calculated using the formula given below : EMI = loan amount * monthly interest rate / ( 1 \u2013 1 / (1 + monthly interest rate)^(number of years * 12)) Constraints: 1 <= P <= 1000000 1 <=T <= 50 1<= N1 <= 30 1<= N2 <= 30 Input Format: First line: P principal (Loan Amount) Second line: T Total Tenure (in years). Third Line: N1 is the number of slabs of interest rates for a given period by Bank A. The first slab starts from the first year and the second slab starts from the end of the first slab and so on. Next N1 line will contain the interest rate and their period. After N1 lines we will receive N2 viz. the number of slabs offered by the second bank. Next N2 lines are the number of slabs of interest rates for a given period by Bank B. The first slab starts from the first year and the second slab starts from the end of the first slab and so on. The period and rate will be delimited by a single white space. Output Format:\u00a0Your decision is either Bank A or Bank B. Example 1 Input 10000\n20\n3\n5 9.5\n10 9.6\n5 8.5\n3\n10 6.9\n5 8.5\n5 7.9 Output: Bank B Example 2 Input 500000\n26\n3\n13 9.5\n3 6.9\n10 5.6\n3\n14 8.5\n6 7.4\n6 9.6 Output: Bank A",
    "example": null,
    "input": null,
    "output": [
      "Bank B",
      "Bank A"
    ],
    "solution": "Solution: bank = [] principal = int(input()) year = int(input()) for i in range(2): installments = int(input()) sum = 0 for i in range(0, installments): year, roi = map(float,input().split()) year = int(year) square = pow((1+roi),year*12) emi = (principal*(roi)/(1-1/square)) sum = sum + emi bank.append(sum) if bank[0] < bank[1]: print(\"Bank A\") else: print(\"Bank B\")"
  },
  {
    "id": 10,
    "problem_statement": "Problem Statement: Some prime numbers can be expressed as a sum of other consecutive prime numbers. For example 5 = 2 + 3, 17 = 2 + 3 + 5 + 7, 41 = 2 + 3 + 5 + 7 + 11 + 13. Your task is to find out how many prime numbers which satisfy this property are present in the range 3 to N subject to a constraint that summation should always start with number 2. Write code to find out the number of prime numbers that satisfy the above-mentioned property in a given range. Input Format:\u00a0First line contains a number N Output Format:\u00a0Print the total number of all such prime numbers which are less than or equal to N. Constraints :\u00a0 2<N<=12,000,000,000 Example\u00a0 : Input : 20 Output : 2 Explanation : Below 20, there are 2 such numbers,\u00a0\n5=2+3\n17=2+3+5+7",
    "example": [
      "Example\u00a0 : Input : 20 Output : 2 Explanation : Below 20, there are 2 such numbers,\u00a0\n5=2+3\n17=2+3+5+7"
    ],
    "input": [
      "20"
    ],
    "output": [
      "2 Explanation : Below 20, there are 2 such numbers,\u00a0\n5=2+3\n17=2+3+5+7"
    ],
    "solution": "Solution:- from collections import defaultdict D=defaultdict(int) AnsString=\"\" s,r=map(int,input().split()) L=list(map(int,input().split())) for i in L: D[i]=1 for i in range(r): a,b=map(int,input().split()) ans=0 for j in range(a,b+1): if D[j]: ans+=1 AnsString+=str(ans)+\" \" print(AnsString)"
  },
  {
    "id": 11,
    "problem_statement": "Problem Statement: Given an array of integers where every element appears even number of times except one element which\u00a0appears odd number of times, write a program to find that odd occurring element in O(log n) time.\u00a0The equal elements must appear in pairs in the array but there cannot be more than two consecutive\u00a0occurrences of an element.\u00a0\n\nFor example :\u00a0\n\n3\u00a0\n\n2 3 2\u00a0\n\nIt doesn't have equal elements appear in pairs\u00a0\n\n7\u00a0\n\n1 1 2 2 2 3 3\u00a0\n\nIt contains three consecutive instances of an element.\u00a0\n\n5\u00a0\n\n2 2 3 1 1\u00a0\n\nIt is valid and the odd occurring element present in it is 3.\u00a0\n\nEnter only valid inputs.\u00a0\n\nSample Input :\u00a0\n\n5\u00a0\n\n2 2 3 1 1\u00a0\n\nSample Output :\u00a0\n\n3",
    "example": null,
    "input": [
      "5\u00a0\n\n2 2 3 1 1\u00a0\n\nSample"
    ],
    "output": [
      "3"
    ],
    "solution": "Solution:- n = int(input()) a = list(map(int,input().split())) left=0 right=n-1 if a[0] != a[1]: print(a[0]) elif a[n-1] != a[n-2]: print(a[n-1]) else: while left <= right: mid = ((right-left)//2)+left pre = mid-1 nxt = mid+1 if (a[pre] != a[mid])\u00a0 and (a[nxt] != a[mid]): print(a[mid]) break elif mid%2==0 : if a[pre] == a[mid] : right = mid - 1 else : left = mid + 1 else : if a[pre] == a[mid] : left = mid + 1 else : right = mid - 1;"
  },
  {
    "id": 12,
    "problem_statement": "Problem Statement: Given an array of integers and a sum, the task is to count all subsets of given array with sum equal to given sum. Input : The first line of input contains an integer T denoting the number of test cases. Then T test cases\u00a0follow. Each test case contains an integer n denoting the size of the array. The next line contains\u00a0n space separated integers forming the array. The last line contains the sum. Output : Count all the subsets of given array with sum equal to given sum. NOTE: Since result can be very large, print the value modulo 109+7. Constraints :\u00a0\n\n1<=T<=100\u00a0\n\n1<=n<=103 1<=a[i]<=103 1<=sum<=103 Example : Input : 2 6 2 3 5 6 8 10 10 5 1 2 3 4 5 10 Output : 3 3 Explanation : Testcase 1: possible subsets : (2,3,5) , (2,8) and (10) Testcase 2: possible subsets : (1,2,3,4) , (2,3,5) and (1,4,5)",
    "example": [
      "Example : Input : 2 6 2 3 5 6 8 10 10 5 1 2 3 4 5 10 Output : 3 3 Explanation : Testcase 1: possible subsets : (2,3,5) , (2,8) and (10) Testcase 2: possible subsets : (1,2,3,4) , (2,3,5) and (1,4,5)"
    ],
    "input": [
      "The first line of input contains an integer T denoting the number of test cases. Then T test cases\u00a0follow. Each test case contains an integer n denoting the size of the array. The next line contains\u00a0n space separated integers forming the array. The last line contains the sum.",
      "2 6 2 3 5 6 8 10 10 5 1 2 3 4 5 10"
    ],
    "output": [
      "Count all the subsets of given array with sum equal to given sum. NOTE: Since result can be very large, print the value modulo 109+7. Constraints :\u00a0\n\n1<=T<=100\u00a0\n\n1<=n<=103 1<=a[i]<=103 1<=sum<=103",
      "3 3 Explanation : Testcase 1: possible subsets : (2,3,5) , (2,8) and (10) Testcase 2: possible subsets : (1,2,3,4) , (2,3,5) and (1,4,5)"
    ],
    "solution": "Solution:- def printBool(n, len): while n: if n & 1: print(\"1 \") else: print(\"0 \") n = n >> 1 len -= 1 while len: print(\"0 \") len -= 1 print() def printSubsetsCount(set, n, val): sum = 0 count = 0 for i in range(0, 1 << n): sum = 0 for j in range(0, n): if (i & 1 << j) > 0: sum += set[j] if (sum == val): count += 1 if (count == 0): print(\"No subset is found\") else: print(count) t=int(input()) set = [] while t>0: n = int(input()) set = list((map(int,input().strip().split())))[:n] Sum = int(input()) printSubsetsCount(set, n, Sum) t = t-1"
  },
  {
    "id": 13,
    "problem_statement": "Problem Statement: Before the outbreak of corona virus to the world, a meeting happened in a room in Wuhan. A person who attended that meeting had COVID-19 and no one in the room knew about it! So everyone started shaking hands with everyone else in the room as a gesture of respect and after meeting unfortunately every one got infected! Given the fact that any two persons shake hand exactly once, Can you tell the total count of handshakes happened in that meeting? Input Format : The first line contains the number of test cases T, T lines follow. Each line then contains an integer N, the total number of people attended that meeting. Output Format : Print the number of handshakes for each test-case in a new line. Constraints : 1 <= T <= 1000 0 < N < 106 Sample Input : 2 1 2 Output : 0 1 Explanation : Case 1 : The lonely board member shakes no hands, hence 0. Case 2 : There are 2 board members, 1 handshake takes place.",
    "example": null,
    "input": [
      "2 1 2"
    ],
    "output": [
      "0 1 Explanation : Case 1 : The lonely board member shakes no hands, hence 0. Case 2 : There are 2 board members, 1 handshake takes place."
    ],
    "solution": "Solution: t = int(input()) while t > 0 : n = int(input()) n = n-1; print((n*(n+1))//2) t = t-1"
  },
  {
    "id": 14,
    "problem_statement": "Problem Statement: For enhancing the book reading, the school distributed story books to students as part of the Children\u2019s Day celebrations. To increase the reading habit, the class teacher decided to exchange the books every week so that everyone will have a different book to read. She wants to know how many possible exchanges are possible. If they have 4 books and students, the possible exchanges are 9. Bi is the book of i-th student and after the\u00a0exchange, he should get a different book, other than Bi. B1 B2 B3 B4 \u2013 first state, before exchange of the books B2 B1 B4 B3 B2 B3 B4 B1 B2 B4 B1 B3 B3 B1 B4 B2 B3 B4 B1 B2 B3 B4 B2 B1 B4 B1 B2 B3 B4 B3 B1 B2 B4 B3 B2 B1 Find the number of possible exchanges, if the books are exchanged so that every student will receive a\u00a0different book. Constraints 1<= N <= 1000000 Input Format Input contains one line with N, indicates the number of books and number of students. Output Format Output the answer modulo 100000007. Refer the sample output for formatting Sample Input : 4 Sample Output : 9",
    "example": null,
    "input": [
      "4 Sample"
    ],
    "output": [
      "9"
    ],
    "solution": "Solution: mod = 100000007; a=0 b=1 c=2 d=0 n = int(input()) if n==1 or n==2: print(n-1) else : for i in range(1,n) : d = (c * (a + b)) % mod a = b b = d c = c + 1 print(d)"
  },
  {
    "id": 15,
    "problem_statement": "Problem Statement: You are given a string A and you have to find the number of different sub-strings of the string A which are\u00a0fake palindromes.\u00a0\n\nNote:\u00a0\n\n1. Palindrome: A string is called a palindrome if you reverse the string yet the order of letters remains\u00a0the same. For example, MADAM.\u00a0\n\n2. Fake Palindrome: A string is called as a fake palindrome if any of its permutations is a palindrome.\u00a0For example, AAC is fake palindrome, but ACD is not.\u00a0\n\n3. Sub-string: A sub-string is a contiguous sequence (non-empty) of characters within a string.\u00a0\n\n4. Two sub-strings are considered same if their starting indices and ending indices are equal.\u00a0\n\nInput Format:\u00a0\n\nFirst line contains a string S\u00a0\n\nOutput Format:\u00a0\n\nPrint a single integer (number of fake palindrome sub-strings).\u00a0\n\nConstraints:\u00a0\n\n1 <= |S| <= 2 * 105\u00a0\n\nThe string will contain only Upper case 'A' to 'Z'\u00a0\n\nSample Input 1:\u00a0\n\nABAB\u00a0\n\nSample Output 1:\u00a0\n\n7\u00a0\n\nExplanation:\u00a0\n\nThe fake palindrome for the string ABAB are A, B, A, B, ABA, BAB, ABAB.\u00a0\n\nSample Input 2:\u00a0\n\nAAA\u00a0\n\nSample output 2:\u00a0\n\n6\u00a0\n\nExplanation:\u00a0\n\nThe fake palindrome for the string AAA are A, A, A, AA, AA, AAA",
    "example": null,
    "input": null,
    "output": null,
    "solution": "Solution: def countSubString(s): res = 0; for i in range(len(s)): x = 0; for j in range(i, len(s)): temp = 1 << ord(s[j]) - ord('a'); x ^= temp; if ((x & (x - 1)) == 0): res += 1; print(res); if __name__ == '__main__': str = input(); countSubString(str);"
  },
  {
    "id": 16,
    "problem_statement": "Problem Statement: You are given a binary tree with\u00a0N\u00a0nodes where each node contains a positive integer value. The goal is to find the\u00a0maximum sum\u00a0path from the root to any leaf node. However, you need to ensure that the sum of the values along the path is\u00a0not\u00a0divisible by a given integer\u00a0K. Input: The first line of input contains an integer\u00a0N, the number of nodes in the tree. The second line contains\u00a0N\u00a0space-separated integers representing the values of the nodes. The third line contains\u00a0N-1\u00a0pairs of integers\u00a0u\u00a0and\u00a0v, representing the edges of the tree (the tree is rooted at node 1). The fourth line contains a single integer\u00a0K, the divisor. Output: Print the maximum sum of the path from the root to any leaf node such that the sum is not divisible by\u00a0K. If no such path exists, print\u00a0-1. Input: 7 3 4 8 2 1 6 10 1 2 1 3 2 4 2 5 3 6 3 7 5 Output: 21 Explanation: The possible paths from the root (node 1) to the leaves are: 3 -> 4 -> 2 (sum = 9) 3 -> 4 -> 1 (sum = 8) 3 -> 8 -> 6 (sum = 17) 3 -> 8 -> 10 (sum = 21) The path with the maximum sum that is not divisible by 5 is\u00a03 -> 8 -> 10, with a sum of 21. Notes: Consider edge cases where no valid path exists. Optimize the solution for large inputs where\u00a0N\u00a0can be as large as\u00a0100,000.",
    "example": null,
    "input": [
      "The first line of input contains an integer\u00a0N, the number of nodes in the tree. The second line contains\u00a0N\u00a0space-separated integers representing the values of the nodes. The third line contains\u00a0N-1\u00a0pairs of integers\u00a0u\u00a0and\u00a0v, representing the edges of the tree (the tree is rooted at node 1). The fourth line contains a single integer\u00a0K, the divisor.",
      "7 3 4 8 2 1 6 10 1 2 1 3 2 4 2 5 3 6 3 7 5"
    ],
    "output": [
      "Print the maximum sum of the path from the root to any leaf node such that the sum is not divisible by\u00a0K. If no such path exists, print\u00a0-1.",
      "21 Explanation: The possible paths from the root (node 1) to the leaves are: 3 -> 4 -> 2 (sum = 9) 3 -> 4 -> 1 (sum = 8) 3 -> 8 -> 6 (sum = 17) 3 -> 8 -> 10 (sum = 21) The path with the maximum sum that is not divisible by 5 is\u00a03 -> 8 -> 10, with a sum of 21. Notes: Consider edge cases where no valid path exists. Optimize the solution for large inputs where\u00a0N\u00a0can be as large as\u00a0100,000."
    ],
    "solution": "Solution:- def dfs(node, parent, current_sum):\n\u00a0 \u00a0 global max_sum\n\u00a0 \u00a0 current_sum += values[node - 1] is_leaf = True\n\u00a0 \u00a0 for neighbor in adj[node]:\n\u00a0 \u00a0 \u00a0 \u00a0 if neighbor != parent:\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 is_leaf = False\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 dfs(neighbor, node, current_sum) if is_leaf and current_sum % K != 0:\n\u00a0 \u00a0 \u00a0 \u00a0 max_sum = max(max_sum, current_sum) N = int(input())\nvalues = list(map(int, input().split()))\nadj = {i: [] for i in range(1, N + 1)} for _ in range(N - 1):\n\u00a0 \u00a0 u, v = map(int, input().split())\n\u00a0 \u00a0 adj[u].append(v)\n\u00a0 \u00a0 adj[v].append(u) K = int(input())\nmax_sum = -1 dfs(1, -1, 0)\nprint(max_sum)"
  }
]